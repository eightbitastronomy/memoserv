//  utckeeper.rs
//
//  Author: Miguel Abele (eightbitastronomy@protonmail.com)
//  Copyrighted by Miguel Abele (eightbitastronomy), 2025.
//
//  License information:
//
//  This file is a part of MemoServ.
//
//  MemoServ is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 3
//  of the License, or (at your option) any later version.
//
//  MemoServ is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


use std::collections::VecDeque;
use std::cmp::Ordering;
use std::fs;
use chrono::{
    Utc,
    TimeDelta,
    DateTime
};
use crate::dbhexgenerator::DBHexGenerator;
use crate::emptygenerator::EmptyGenerator;
use crate::mberror::MBError;
use crate::backer::{
    Backer, 
    BuNumber, 
    BackCopy
};
use crate::utcbackup::UtcBackup;
use crate::backerparserjson::BackerParserJSON;
use json::object;



#[derive(Clone)]
pub struct UtcKeeper {

    frequency: BuNumber,
    multiplicity: BuNumber,
    copies: VecDeque<UtcBackup>,
    base: String,
    suffix: String,
    cfgsuffix: String,
    location: String,
    version: String

}


unsafe impl Send for UtcKeeper {}


impl UtcKeeper {


    pub fn default() -> UtcKeeper {
        UtcKeeper {
            frequency: 0,
            multiplicity: 0,
            copies: VecDeque::default(),
            base: "".to_string(),
            suffix: "".to_string(),
            cfgsuffix: "".to_string(),
            location: "".to_string(),
            version: "".to_string()
        }
    }


    pub fn new(freq: BuNumber, mult: BuNumber, mut copyvec: Vec<UtcBackup>) -> UtcKeeper {
        if !copyvec.is_empty() {
            copyvec.sort_by(
                |a,b| {
                    match a.date() {
                        x if x < b.date() => Ordering::Greater,
                        x if x == b.date() => Ordering::Equal,
                        _ => Ordering::Less 
                    }
                }
            );
        }
        UtcKeeper {
            frequency: if freq < 1 {
                1
            } else {
                freq
            },
            multiplicity: if mult < 2 {
                1
            } else {
                mult
            },
            copies: if copyvec.is_empty() {
                VecDeque::new()
            } else {
                while copyvec.len() > (mult as usize) {
                    copyvec.pop();
                }
                VecDeque::from(copyvec)
            },
            base: "mbsnapshot".to_string(),
            suffix: "db".to_string(),
            cfgsuffix: "json".to_string(),
            location: "".to_string(),
            version: "json_utc_01_00".to_string()
        }
    }


    fn generate(&self) -> Result<(String, String), MBError> {
        let namer: DBHexGenerator = DBHexGenerator::new();
        match 
            if self.location.is_empty() {
                namer.generate(&self.base, vec![&self.suffix, &self.cfgsuffix])
            } else {
                namer.generate(format!("{}/{}", self.location, self.base).as_str(), vec![&self.suffix, &self.cfgsuffix])
            }
        {
            Ok(mut resv) => {
                if resv.len() == 2 {
                    Ok((resv.remove(0),resv.remove(0)))
                } else {
                    Err(MBError::Backup("improper number of file names generated by DBHexGenerator for backup creation".to_string()))
                }
            },
            Err(e) => Err(e)
        }
    }


}



//impl Backer<UtcBackup> for UtcKeeper {
impl Backer for UtcKeeper {

    type BItem = UtcBackup;

    fn pop(&mut self, target: &str) -> Option<UtcBackup> {
        if self.copies.is_empty() {
            return None;
        }
        let mut hit: Option<usize> = None;
        for (i, copyitem) in self.copies.iter().enumerate() {
            if (copyitem.path().as_str() == target) || (format!("{:?}",copyitem.date()).as_str() == target) {
                hit = Some(i);
                break;
            }
        }
        if let Some(index) = hit {
            self.copies.remove(index)
        } else {
            None
        }
    }


    fn get(&self, target: &str) -> Option<&UtcBackup> {
        if self.copies.is_empty() {
            return None;
        }
        let mut hit: Option<usize> = None;
        for (i, copyitem) in self.copies.iter().enumerate() {
            if (copyitem.path().as_str() == target) || (format!("{:?}",copyitem.date()).as_str() == target) {
                hit = Some(i);
                break;
            }
        }
        if let Some(index) = hit {
            Some(&self.copies[index])
        } else {
            None
        }
    }


    fn pop_most_recent(&mut self) -> Option<UtcBackup> {
        self.copies.pop_front()
    }


    fn get_most_recent(&self) -> Option<UtcBackup> {
        if !self.copies.is_empty() {
            Some(self.copies[0].clone())
        } else {
            None
        }
    }


    fn pop_least_recent(&mut self) -> Option<UtcBackup> {
        self.copies.pop_back()
    }


    fn get_least_recent(&self) -> Option<UtcBackup> {
        if !self.copies.is_empty() {
            Some(self.copies[self.copies.len()-1].clone())
        } else {
            None
        }
    }


    fn push(&mut self, item: UtcBackup) {
        if (!self.copies.is_empty()) && (self.copies.len() == (self.multiplicity as usize)) {
            let erasable = self.copies.pop_back();
            self.erase(erasable);
        }     
        self.copies.push_back(item);
        let unsorted = self.copies.make_contiguous();
        unsorted.sort_by(
            |a,b| {
                /*if a.date() < b.date() {
                    Ordering::Greater
                } else if a.date() == b.date() {
                    Ordering::Equal
                } else {
                    Ordering::Less
                }*/
                match a.date() {
                    x if x < b.date() => Ordering::Greater,
                    x if x == b.date() => Ordering::Equal,
                    _ => Ordering::Less 
                }
            }
        );
        self.copies = VecDeque::from(Vec::from(unsorted)); 
    }


    fn erase(&self, targ: Option<UtcBackup>) {
        // For now, failure is silent
        let Some(t) = targ else {
            return;
        };
        match fs::remove_file(t.path()) {
            Ok(_) => {},
            Err(_) => {
                //return Err(MBError::FileSys(format!("error deleting backup file: {e}")));
            }
        }
        for item in t.aux() {
            match fs::remove_file(item) {
                Ok(_) => {},
                Err(_) => {
                    //return Err(MBError::FileSys(format!("error deleting backup file: {e}")));
                }
            }
        }
    }


    fn remove(&mut self, target: &str) {
        if self.copies.is_empty() {
            return;
        }
        let mut hit: Option<usize> = None;
        for (i, copyitem) in self.copies.iter().enumerate() {
            if (copyitem.path().as_str() == target) || (format!("{:?}",copyitem.date()).as_str() == target) {
                hit = Some(i);
                break;
            }
        }
        if let Some(index) = hit {
            self.copies.remove(index);
        }
    }


    fn remove_and_erase(&mut self, targ: Option<&UtcBackup>) {
        // For now, failure is silent
        let Some(t) = targ else {
            return;
        };
        match fs::remove_file(t.path()) {
            Ok(_) => {},
            Err(_) => {
                //println!("Can't delete file: {:?}", e);
            }
        }
        for item in t.aux() {
            match fs::remove_file(item) {
                Ok(_) => {},
                Err(_) => {
                    //println!("Can't delete aux file: {:?}", e);
                }
            }
        }
        self.remove(t.path().as_str());
    }


    fn get_frequency(&self) -> BuNumber {
        self.frequency
    }


    fn set_frequency(&mut self, freq: BuNumber) {
        self.frequency = if freq < (1 as BuNumber) {
            1
        } else {
            freq
        };
    }


    fn get_multiplicity(&self) -> BuNumber {
        self.multiplicity
    }


    fn set_multiplicity(&mut self, mult: BuNumber) {
        self.multiplicity = if mult < (2 as BuNumber) {
            1
        } else {
            mult
        };
    }


    #[allow(refining_impl_trait)]
    fn iter(&self) -> impl Iterator<Item=&UtcBackup> { // + use <'_> {
    //fn iter(&self) -> BackupIterator {
        BackupIterator {
            list: &self.copies,
            index: 0,
            len: self.copies.len()
        }
    }


    fn set_base(&mut self, base: &str) {
        self.base = base.to_string();
    }


    fn set_suffix(&mut self, portion: &[String]) {
        if portion.len() < 2 {
            return;
        }
        self.suffix = portion[0].to_string();
        self.cfgsuffix = portion[1].to_string();
    }

    
    fn get_base(&self) -> String {
        self.base.clone()
    }


    fn get_suffix(&self) -> Vec<String> {
        vec![self.suffix.clone(), self.cfgsuffix.clone()]
    }


    fn set_location(&mut self, loc: &str) {
        self.location = loc.to_string();
    }


    fn get_location(&self) -> String {
        self.location.clone()
    }


    fn check(&self) -> bool {
        if let Some(recent) = self.get_most_recent() {
            (Utc::now() - recent.date()) >= TimeDelta::days(self.frequency.into())
        } else {
            true
        }
    }


    fn make(&mut self, src: &str, aux: &[&str]) -> Result<(), MBError> {
        if aux.len() != 1 {
            return Err(MBError::Backup("Bad make() call".to_string()));
        }
        let (targetdb, targetconf) = match self.generate() {
            Ok(s) => s,
            Err(e) => { return Err(e); }
        };
        match (fs::copy(src, &targetdb), fs::copy(aux[0], &targetconf)) {
            (Ok(_), Ok(_)) => {
                self.push(
                    UtcBackup::new(&targetdb, &targetconf, &Utc::now())
                );
                Ok(())
            },
            (Err(e), Ok(_)) => {
                Err(MBError::FileSys(format!("unable to make backup file: {e}")))
            },
            (Ok(_), Err(e)) => {
                Err(MBError::FileSys(format!("unable to make backup file: {e}")))
            },
            _ => {
                Err(MBError::FileSys("unable to make backup files".to_string()))
            }
        }
    }


    fn set_version(&mut self, vers: &str) {
        self.version = vers.to_string();
    }


    fn version(&self) -> String {
        self.version.clone()
    }


}


pub struct BackupIterator<'a> {
    list: &'a VecDeque<UtcBackup>,
    index: usize,
    len: usize
}


impl<'a> Iterator for BackupIterator<'a> {
    
    type Item = &'a UtcBackup; 

    fn next(&mut self) -> Option<Self::Item> {
        let ret = if self.index < self.len {
            Some(&self.list[self.index])
        } else {
            None
        };
        self.index += 1;
        ret   
    }

}



impl BackerParserJSON for UtcKeeper {


    //type CopyItem = UtcBackup; 
    //type Item = UtcKeeper;


    //fn read(source: &json::JsonValue) -> Result<UtcKeeper, String> {
    fn read(&mut self, source: &json::JsonValue) -> Result<(), String> {
        let vers: String = match &source["database"]["back"]["version"] {
            json::JsonValue::Short(x) => x.to_string(),
            json::JsonValue::String(z) => z.to_owned(),
            _ => { return Err("Parse error on backup object".to_string()); }
        };
        if vers != "json_utc_01_00" {
            return Err("Backup object version mismatch".to_string());
        }
        let freq: BuNumber = match &source["database"]["back"]["frequency"] {
            json::JsonValue::Number(n) => {
                match n.to_string().parse::<BuNumber>() {
                    Ok(o) => o,
                    Err(_) => { return Err("Parse error on frequency".to_string()); }
                }
            },
            json::JsonValue::Short(x) => { 
                match x.to_string().parse::<BuNumber>() {
                    Ok(val) => val,
                    Err(_) => { return Err("Parse error on backup object".to_string()); }
                }
            },
            json::JsonValue::String(z) => {
                match z.to_string().parse::<BuNumber>() {
                    Ok(val) => val,
                    Err(_) => { return Err("Parse error on backup object".to_string()); }
                }
            },
            _ => { return Err("Parse error on backup object".to_string()); }
        };
        let mult: BuNumber = match &source["database"]["back"]["multiplicity"] {
            json::JsonValue::Number(n) => {
                match n.to_string().parse::<BuNumber>() {
                    Ok(o) => o,
                    Err(_) => { return Err("Parse error on multiplicity".to_string()); }
                }
            },
            json::JsonValue::Short(x) => { 
                match x.to_string().parse::<BuNumber>() {
                    Ok(val) => val,
                    Err(_) => { return Err("Parse error on backup object".to_string()); }
                }
            },
            json::JsonValue::String(z) => {
                match z.to_string().parse::<BuNumber>() {
                    Ok(val) => val,
                    Err(_) => { return Err("Parse error on backup object".to_string()); }
                }
            },
            _ => { return Err("Parse error on backup object".to_string()); }
        };
        let base: &str = match &source["database"]["back"]["base"] {
            json::JsonValue::String(x) => x.as_str(),
            json::JsonValue::Short(x) => x.as_str(),
            _ => { return Err("Parse error on backup object".to_string()); }
        };
        let suffixvec: Vec<String> = match &source["database"]["back"]["suffix"] {
            json::JsonValue::Array(a) => {
                a.iter().map(
                    |y| match y {
                        json::JsonValue::String(z) => z.to_owned(),
                        json::JsonValue::Short(z) => z.to_string(),
                        _ => "".to_string()
                    }
                ).collect()
            },
            _ => {
                return Err("Parse error on backup object suffix array".to_string());
            }
        };
        if suffixvec.len() < 2 {
            return Err("Parse error on backup object suffix array".to_string());
        }
        let suffix: &str = suffixvec[0].as_str();
        let cfgsuffix: &str = suffixvec[1].as_str();
        let location: String = match &source["database"]["back"]["location"] {
            json::JsonValue::String(x) => x.to_owned(),
            json::JsonValue::Short(x) => x.to_string(),
            _ => { return Err("Parse error on backup object".to_string()); }
        };
        let mut copiesvec: Vec<UtcBackup> = Vec::new();
        if source["database"]["back"]["copies"].is_array() {
            if let json::JsonValue::Array(x) = &source["database"]["back"]["copies"] {
                let incvec: Vec<String> = x.iter().map(
                    |y| match y {
                        json::JsonValue::String(z) => z.to_owned(),
                        json::JsonValue::Short(z) => z.to_string(),
                        _ => "".to_string()
                    }
                    ).collect();
                for item in incvec.into_iter() {
                    let sitem = item.split(' ').collect::<Vec<_>>();
                    //println!("item is {:?}", sitem);
                    match sitem[..] {
                        [a,b,c] => { 
                            match DateTime::parse_from_rfc3339(c) {
                                Ok(dt) => copiesvec.push(
                                    UtcBackup::new( 
                                        a, 
                                        b, 
                                        &chrono::DateTime::from(dt)
                                    )
                                ),
                                Err(_) => { return Err("Parse error on datetime object".to_string()); }
                            }
                            
                        },
                        _ => { 
                            //println!("item in incvec parsed {}", item); 
                            continue; 
                        }
                    }
                }
            }
        }
        if !copiesvec.is_empty() {
            copiesvec.sort_by(
                |a,b| {
                    match a.date() {
                        x if x < b.date() => Ordering::Greater,
                        x if x == b.date() => Ordering::Equal,
                        _ => Ordering::Less 
                    }
                }
            );
        }
        self.version = vers.to_string();
        self.frequency = freq;
        self.multiplicity = mult;
        self.copies = if copiesvec.is_empty() {
            VecDeque::new()
        } else {
            while copiesvec.len() > (mult as usize) {
                copiesvec.pop();
            }
            VecDeque::from(copiesvec)
        };
        self.base = base.to_string();
        self.suffix = suffix.to_string();
        self.cfgsuffix = cfgsuffix.to_string();
        self.location = location;
        Ok(())
    }


    fn write(&self) -> Result<json::JsonValue, String> {
        let jback = object!{
            version: self.version.clone(),
            frequency: self.frequency,
            multiplicity: self.multiplicity,
            copies: self.iter().map(|x: &UtcBackup| 
                {
                    let tempvec = x.aux();
                    if tempvec.is_empty() {
                        None
                    } else {
                        Some(format!("{} {} {}", x.path(), tempvec[0], x.date().format("%+")))
                    }
                }).collect::<Vec<_>>(),
            base: self.base.clone(),
            suffix: vec![self.suffix.clone(), self.cfgsuffix.clone()],
            location: self.location.clone()
        };
        Ok(jback)
    }

}


/****** These tests probably no longer work properly, need to rewrite  ******/


#[cfg(test)]
mod tests {

    use super::*;
    use std::fs;
    use chrono::TimeZone;


    #[test]
    fn test_new_low_mult() {
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let b3: UtcBackup = UtcBackup::new("monser.d", "conf3.json", &Utc.with_ymd_and_hms(2012, 9, 9, 5, 5, 5).unwrap());//2012-09-09T05:05:05Z 
        let mut holder = UtcKeeper::new(20, 2, vec![b1, b2, b3]);
        let Some(p1) = holder.pop_most_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("diabl.d", p1.path().as_str());
        assert_eq!("2015-07-10T20:10:11Z", format!("{:?}",p1.date()).as_str());
        assert_eq!("conf2.json", p1.aux()[0].as_str());
        let Some(p2) = holder.pop_most_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("arbit.d", p2.path().as_str());
        assert_eq!("2014-07-08T09:10:11Z", format!("{:?}",p2.date()).as_str());
        assert_eq!("conf.json", p2.aux()[0].as_str());
        match holder.pop_most_recent() {
            Some(_) => assert!(false),
            None => assert!(true)
        }
        //assert_eq!(holder.pop_most_recent(), None);
    }

    #[test]
    fn test_new_large_mult() {
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let mut holder = UtcKeeper::new(20, 4, vec![b1, b2]);
        let Some(p1) = holder.pop_most_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("diabl.d", p1.path().as_str());
        assert_eq!("2015-07-10T20:10:11Z", format!("{:?}",p1.date()).as_str());
        assert_eq!("conf2.json", p1.aux()[0].as_str());
        let Some(p2) = holder.pop_least_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("arbit.d", p2.path().as_str());
        assert_eq!("2014-07-08T09:10:11Z", format!("{:?}",p2.date()).as_str());
        assert_eq!("conf.json", p2.aux()[0].as_str());
    }

    #[test]
    fn test_push_large_mult() {
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let mut holder = UtcKeeper::new(20, 4, vec![b1, b2]);
        holder.push(UtcBackup::new("monser.d", "conf3.json", &Utc.with_ymd_and_hms(2012, 9, 9, 5, 5, 5).unwrap()));
        let Some(p1) = holder.pop_most_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("diabl.d", p1.path().as_str());
        assert_eq!("2015-07-10T20:10:11Z", format!("{:?}",p1.date()).as_str());
        let Some(p2) = holder.pop_least_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("monser.d", p2.path().as_str());
        assert_eq!("2012-09-09T05:05:05Z", format!("{:?}",p2.date()).as_str());
    }

    #[test]
    fn test_remove_w_hit_path() {
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let b3: UtcBackup = UtcBackup::new("monser.d", "conf3.json", &Utc.with_ymd_and_hms(2012, 9, 9, 5, 5, 5).unwrap());//2012-09-09T05:05:05Z 
        let mut holder = UtcKeeper::new(20, 2, vec![b1, b2, b3]);
        holder.remove("diabl.d");
        let Some(p1) = holder.pop_most_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("arbit.d", p1.path().as_str());
    }

    #[test]
    fn test_remove_w_hit_date() {
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let b3: UtcBackup = UtcBackup::new("monser.d", "conf3.json", &Utc.with_ymd_and_hms(2012, 9, 9, 5, 5, 5).unwrap());//2012-09-09T05:05:05Z 
        let mut holder = UtcKeeper::new(20, 2, vec![b1, b2, b3]);
        holder.remove("2015-07-10T20:10:11Z");
        let Some(p1) = holder.pop_most_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("arbit.d", p1.path().as_str());
    }

    #[test]
    fn test_remove_w_miss() {
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let b3: UtcBackup = UtcBackup::new("monser.d", "conf3.json", &Utc.with_ymd_and_hms(2012, 9, 9, 5, 5, 5).unwrap());//2012-09-09T05:05:05Z 
        let mut holder = UtcKeeper::new(20, 2, vec![b1, b2, b3]);
        holder.remove("diablo.d");
        let Some(p1) = holder.pop_most_recent() else {
            assert!(false);
            return;
        };
        assert_eq!("diabl.d", p1.path().as_str());
    }

    #[test]
    fn test_name_generation() {
        // Be careful if you modify this: by setting multiplicity, you determine when old files get both removed from the
        //  copies object and deleted from disk. If you don't keep track of which ones ought to be missing by the time
        //  assertions and removals occur, the test will fail even though the code might be running as intended.
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let b3: UtcBackup = UtcBackup::new("monser.d", "conf3.json", &Utc.with_ymd_and_hms(2012, 9, 9, 5, 5, 5).unwrap());//2012-09-09T05:05:05Z 
        let mut holder = UtcKeeper::new(20, 16, vec![b1, b2, b3]);
        holder.make("/home/illudens/code/rust/memoserv/archive.db", &vec!["/home/illudens/code/rust/memoserv/conf.json"]);
        assert_eq!("mbsnapshot0000.db", holder.most_recent().unwrap().path().as_str());
        holder.make("/home/illudens/code/rust/memoserv/archive.db", &vec!["/home/illudens/code/rust/memoserv/conf.json"]);
        assert_eq!("mbsnapshot0001.db", holder.most_recent().unwrap().path().as_str());
        fs::remove_file("mbsnapshot0000.db");
        fs::remove_file("mbsnapshot0000.json");
        fs::remove_file("mbsnapshot0001.db");
        fs::remove_file("mbsnapshot0001.json");
        holder.set_base("arguable");
        holder.set_suffix(&vec!["tat".to_string(), "ext".to_string()]);
        let mut auxvec: Vec<&str> = vec![
            "arguable0000.ext",
            "arguable0001.ext",
            "arguable0002.ext",
            "arguable0003.ext",
            "arguable0004.ext",
            "arguable0005.ext",
            "arguable0006.ext",
            "arguable0007.ext",
            "arguable0008.ext",
            "arguable0009.ext",
            "arguable000A.ext",
            "arguable000B.ext",
            "arguable000C.ext",
            "arguable000D.ext",
            "arguable000E.ext",
            "arguable000F.ext",
            "arguable0010.ext",
        ];
        let mut namesvec: Vec<&str> = vec![
            "arguable0000.tat",
            "arguable0001.tat",
            "arguable0002.tat",
            "arguable0003.tat",
            "arguable0004.tat",
            "arguable0005.tat",
            "arguable0006.tat",
            "arguable0007.tat",
            "arguable0008.tat",
            "arguable0009.tat",
            "arguable000A.tat",
            "arguable000B.tat",
            "arguable000C.tat",
            "arguable000D.tat",
            "arguable000E.tat",
            "arguable000F.tat",
            "arguable0010.tat"
        ];
        for item in namesvec.iter() {
            match holder.make(
                "/home/illudens/code/rust/memoserv/archive.db", 
                &vec!["/home/illudens/code/rust/memoserv/conf.json"])
            {
                Ok(_) => {},
                Err(e) => panic!("{}", format!("Cannot make {}: {e}", item))
            }
            assert_eq!(*item, holder.most_recent().unwrap().path().as_str());
        }
        match holder.make(
            "/home/illudens/code/rust/memoserv/archive.db", 
            &vec!["/home/illudens/code/rust/memoserv/conf.json"])
        {
            Ok(_) => {},
            Err(e) => panic!("{}", format!("Cannot make backup: {e}"))
        }
        assert_eq!(namesvec[0], holder.most_recent().unwrap().path().as_str());
        namesvec.remove(1);
        auxvec.remove(1);
        for item in namesvec.iter() {
            _ = fs::remove_file(item).expect(format!("Cannot delete {item}").as_str());
        }
        for item in auxvec.iter() {
            _ = fs::remove_file(item).expect(format!("Cannot delete {item}").as_str());
        }
    }


    #[test]
    fn test_name_generation_w_location() {
        let b1: UtcBackup = UtcBackup::new("arbit.d", "conf.json", &Utc.with_ymd_and_hms(2014, 7, 8, 9, 10, 11).unwrap());//2014-07-08T09:10:11Z
        let b2: UtcBackup = UtcBackup::new("diabl.d", "conf2.json", &Utc.with_ymd_and_hms(2015, 7, 10, 20, 10, 11).unwrap());//2015-07-10T20:10:11Z
        let b3: UtcBackup = UtcBackup::new("monser.d", "conf3.json", &Utc.with_ymd_and_hms(2012, 9, 9, 5, 5, 5).unwrap());//2012-09-09T05:05:05Z 
        let mut holder = UtcKeeper::new(20, 2, vec![b1, b2, b3]);
        holder.set_location("/home/illudens/code/rust");
        holder.set_base("barbie");
        holder.set_suffix(&vec!["doll".to_string(),"house".to_string()]);
        //let place1: String = holder.generate().unwrap();
        holder.make("/home/illudens/code/rust/memoserv/archive.db", &vec!["/home/illudens/code/rust/memoserv/conf.json"]);
        assert_eq!("/home/illudens/code/rust/barbie0000.doll", holder.most_recent().unwrap().path().as_str());
        fs::remove_file("/home/illudens/code/rust/barbie0000.doll");
        fs::remove_file("/home/illudens/code/rust/barbie0000.house");
    }

}
